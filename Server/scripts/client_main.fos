#include "_client_defines.fos"
#include "_macros.fos"
#include "_msgstr.fos"
#include "_colors.fos"
#include "_animation.fos"
#include "sprite.fos"
#include "gui_h.fos"

import void InitializeGame() from "config";
import void InitTestScreen() from "client_screen_test";
import void InitRadioScreen() from "radio";
import bool PerkCheck( CritterCl& cr, uint perk ) from "perks";
import void CritterGenerate( int[]& data ) from "parameters";
import bool CritterGenerateCheck( const int[]& data ) from "parameters";
import void InitNameColorizing() from "name_colorizing";
import bool TryColorizeCritter( CritterCl& cr ) from "name_colorizing";
import bool PlayerIgnored( CritterCl& cr ) from "ignore_list";
import bool IgnorePlayer( string& message ) from "ignore_list";
import void InitIgnoreList() from "ignore_list";
import void InitChosenTabs() from "chosen_tabs";
import void DrawChosenTabs() from "chosen_tabs";
#ifdef PLAYERS_3D
import void Init3DChaRegScreen() from "client_3d_cha_reg";
import void Set3DRegistrationGender( int gender ) from "client_3d_cha_reg";
import void Fill3DRegistrationParameters( int[]& params ) from "client_3d_cha_reg";
#endif
import void PlayAnimSound( uint crType, int gender, uint anim1, uint anim2 ) from "animation";
import uint CheckPlayerName( const string& name ) from "parameters";

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on client loaded or new client_main.fos script received.
bool start()
{
    InitializeGame();
	__ShowPlayerNames = true;
	__ShowNpcNames = true;
    if( __ScreenWidth < 800 || __ScreenWidth > 1280 || __ScreenHeight < 600 || __ScreenHeight > 1024 )
    {
        // Recomendation message
        Message( GetMsgStr( TEXTMSG_GAME, STR_INVALID_RESOLUTION ) );
    }

    #ifdef PLAYERS_3D
    AppendIfaceIni( "players3d_chareg.ini" );
    # ifndef PLAYERS_3D_NO_HEAD
    AppendIfaceIni( "players3d_headinv.ini" );
    # endif
    #endif

    LoadFont( FONT_COURIER_NEW_SMALL, "CourierNewSmall" );
    // SetDefaultFont(FONT_COURIER_NEW_SMALL, COLOR_TEXT);

    GUI_EngineCallback_Start();
    GUI_AddDragAndDropHandler( ItemsDragAndDropHandler );

    InitNameColorizing();
    InitIgnoreList();
    // InitTestScreen();
    InitRadioScreen();
    InitChosenTabs();
    #ifdef PLAYERS_3D
    Init3DChaRegScreen();
    #endif

    // 3d models preloading
    #ifdef PLAYERS_3D
    string[] preload3dFiles =
    {
        "VbAnt.fo3d",
        "VbAntQueen.fo3d",
        "VbBat.fo3d",
        "VbBeetle.fo3d",
        "VbCentipede.fo3d",
        "VbCougar.fo3d",
        "VbCow.fo3d",
        "VbDeathclaw.fo3d",
        "VbDesertStalker.fo3d",
        "VbDog.fo3d",
        "VbGila.fo3d",
        "VbMantrap.fo3d",
        "VbRadToad.fo3d",
        "VbRat.fo3d",
        "VbThornSlinger.fo3d",
        "VbAnt.fo3d",
        "VbWaspGiant.fo3d",
        "VbWeedling.fo3d",
        "VbFemaleFat.fo3d",
        "VbFemaleNormal.fo3d",
        "VbFemaleStrong.fo3d",
        "VbFemaleWiry.fo3d",
        "VbFemaleSkeleton.fo3d",
        "VbMaleFat.fo3d",
        "VbMaleNormal.fo3d",
        "VbMaleStrong.fo3d",
        "VbMaleWiry.fo3d",
        "VbMaleSkeleton.fo3d"
    };
    Preload3dFiles( preload3dFiles, PT_ART_CRITTERS );
    #endif
	
	GetHardware(__HardwareId);	
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on client finish.
void finish()
{
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Main loop function. Returned time of next call in milliseconds.
uint loopCycle = 0;
string prevReceivedMessage = "";

uint loop()
{
	GUI_EngineCallback_ItemChanged(false);
    GUI_EngineCallback_Loop();
	__ConsoleActive = GUI_IsConsoleActive();

	CritterCl@ chosen = GetChosen();
	if(chosen !is null && GetCurrentCursor() == CURSOR_WAIT && !chosen.IsBusy())
		ChangeCursor( CURSOR_DEFAULT );
	
	if(chosen !is null && loopCycle > 100){
	
		RunServerScriptUnsafe("rp_utils@unsafe_refreshLoook", 0,0,0, null, null);
		
		if(chosen.Param[CR_NEED_TO_UPDATE_ACCESS] == 1){
			RunServerScriptUnsafe("rp_utils@unsafe_RetrieveAccess", 0, 0, 0, __HardwareId, null);
		}
		prevReceivedMessage = "";
		loopCycle = 0;
	}

	loopCycle++;
    return 1;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Say to engine what screens is active.
void get_active_screens( int[]& result )
{
    GUI_EngineCallback_GetActiveScreens( result );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Show/hide screen behaviour.
void screen_change( bool show, int screen, dictionary@ params )
{
    if( IS_CLIENT_MAIN_SCREEN( screen ) )
        __ConsoleActive = false;

    if( show )
        GUI_EngineCallback_ShowScreen( screen, params );
    else
        GUI_EngineCallback_HideScreen( screen );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Render interface function. You can use Draw* functions only there.
// Layer specification:
//    1
// Game map
//    2, 3
// PopUp menu, Cursor
//    4
//
// Extra layers:
// Global map
//    100 (over map), 101 (over all)
bool __CrDebugInfo = false;
bool __RenderThrowing = false;
import void RenderThrowing() from "throwing";
bool getNewThrowing(){
	return __RenderThrowing;
}

void setNewThrowing(bool val){
	__RenderThrowing = val;
}

class LaserBeam{

	LaserBeam(){
	}

	uint startTime;
	uint endTime;
	
	uint16 startHexX, startHexY;
	uint16 endHexX, endHexY;
}

array <LaserBeam@> laserBeams;

void addLaserBeam(int, int, int, string@, int[]@ values){
	LaserBeam beam = LaserBeam();
	beam.startHexX = values[0];
	beam.startHexY = values[1];
	beam.endHexX = values[2];
	beam.endHexY = values[3];
	beam.startTime = __FullSecond;
	beam.endTime = __FullSecond + 5;

	laserBeams.insertLast(beam);
}

uint __CurrentTime = __FullSecond;
void render_iface( uint layer )
{

    if( layer == 2 )
    {
		for(uint i = 0; i < laserBeams.length(); i++){
		if(laserBeams[i].startTime < __FullSecond && laserBeams[i].endTime > __FullSecond){
			int x = 0,y = 0, hx = 0, hy = 0;
			GetHexPos(laserBeams[i].startHexX, laserBeams[i].startHexY, x, y);
			GetHexPos(laserBeams[i].endHexX, laserBeams[i].endHexY, hx, hy);
			hy -= uint16(40.0 * 1.0 / __SpritesZoom );
			y -= uint16(40.0 * 1.0 / __SpritesZoom );
			int color = int(COLOR_RED);
			DrawPrimitive(DRAW_PRIMITIVE_LINELIST, array<int> = {x - 1, y - 1, color, hx - 1, hy - 1, color});
			DrawPrimitive(DRAW_PRIMITIVE_LINELIST, array<int> = {x - 1, y + 1, color, hx - 1, hy + 1, color});
			DrawPrimitive(DRAW_PRIMITIVE_LINELIST, array<int> = {x + 1, y - 1, color, hx + 1, hy - 1, color});
			DrawPrimitive(DRAW_PRIMITIVE_LINELIST, array<int> = {x + 1, y + 1, color, hx + 1, hy + 1, color});
			DrawPrimitive(DRAW_PRIMITIVE_LINELIST, array<int> = {x, y, color, hx, hy, color});
		}
	}
	
	if(__TimeBeforeStart > 0)
	{
		DrawText("До начала раунда осталось " + __TimeBeforeStart + " секунд.", __ScreenWidth / 3, 100, __ScreenWidth, __ScreenHeight, COLOR_GREEN, FONT_DEFAULT, 0);
	}
	if(__RenderThrowing && !GUI_IsConsoleActive())
		 RenderThrowing();
		 
	    GUI_EngineCallback_Draw( true );
        DrawChosenTabs();
        GUI_EngineCallback_Draw( false );
		
		// Help info
        if( __HelpInfo )
        {
            // About
            string aboutText =
                "FOnline " + ( __Singleplayer ? "Singleplayer" : "" ) + "\n" +
                "by Gamers for Gamers\n" +
                "version " + CustomCall( "Version" ) + "\n" +
                "\n" +
                "Traffic, bytes:\n" +
                "Send: " + CustomCall( "BytesSend" ) + "\n" +
                "Receive: " + CustomCall( "BytesReceive" ) + "\n" +
                "Sum: " + ( CustomCall( "BytesSend" ).toInt() + CustomCall( "BytesReceive" ).toInt() ) + "\n" +
                "\n" +
                "FPS: " + __FPS + " (" + ( !__VSync ? "" + abs( __FixedFPS ) : "VSync" ) + ( !__VSync && __FixedFPS < 0 ? ", sleep" : "" ) + ")\n" +
                "Ping: " + __Ping + "\n" +
                "\n" +
                "Sound: " + __SoundVolume + "\n" +
                "Music: " + __MusicVolume + "\n";
            if( __DebugInfo )
            {
                aboutText += "\n" +
                             "Focused object: " + ( GUI_GetFocusedObject() !is null ? GUI_GetFocusedObject().Name : "None" ) + "\n" +
                             "Pressed object: " + ( GUI_GetPressedObject() !is null ? GUI_GetPressedObject().Name : "None" ) + "\n" +
                             "Hovered object: " + ( GUI_GetHoveredObject() !is null ? GUI_GetHoveredObject().Name : "None" );
            }
            DrawText( aboutText, 30, 30, __ScreenWidth, __ScreenHeight, COLOR_RGB( 187, 187, 187 ), FONT_BIG, 0 );

            // Help
            DrawText( MSG_GAME( STR_GAME_HELP ), 0, 0, __ScreenWidth, __ScreenHeight, COLOR_WHITE, FONT_DEFAULT, FT_CENTERX | FT_CENTERY );
        }
		
		if(GetChosen() !is null && __CrDebugInfo ){
			CritterCl@ cr = GetChosen();
			string result =
				"Health: \n" +
				"Torso Damage/Burn: " + cr.Param[CR_TORSO_DAMAGE] + "/" + cr.Param[CR_TORSO_BURN] + "\n" +
				"LArm Damage/Burn: " + cr.Param[CR_LEFT_ARM_DAMAGE] + "/" + cr.Param[CR_LEFT_ARM_BURN] + "\n" +
				"RArm Damage/Burn: " + cr.Param[CR_RIGHT_ARM_DAMAGE] + "/" + cr.Param[CR_RIGHT_ARM_BURN] + "\n" +
				"LLeg Damage/Burn: " + cr.Param[CR_LEFT_LEG_DAMAGE] + "/" + cr.Param[CR_LEFT_LEG_BURN] + "\n" +
				"RLeg Damage/Burn: " + cr.Param[CR_RIGHT_LEG_DAMAGE] + "/" + cr.Param[CR_RIGHT_LEG_BURN] + "\n" +
				"Head Damage/Burn: " + cr.Param[CR_HEAD_DAMAGE] + "/" + cr.Param[CR_HEAD_BURN] + "\n" +
				"Internals Damage: " + cr.Param[CR_INTERNALS_DAMAGE] + "\n" +
				"Blood: " + cr.Param[CR_BLOOD] + "/" + cr.Param[CR_MAXBLOOD] + "\n" +
				"Hp: " + getHpPercentage(cr) + "\n" +
				"HeartBeat: " + cr.Param[CR_HEARTBEAT] + "\n" +			
				"Hunger: " + cr.Param[CR_HUNGER] + "\n" +			
				"Thirst: " + cr.Param[CR_THIRST] + "\n" +
				"Anim2: " + cr.Param[CRITTER_CURRENT_ANIM2] + "\n";				
				
            DrawText( result, 10, 10, __ScreenWidth, __ScreenHeight, COLOR_WHITE, FONT_DEFAULT, 0 );

		}

		if(GetMonitorCritter(__MouseX, __MouseY, false) !is null && __CrDebugInfo && GetCurrentCursor() == CURSOR_DEFAULT && !GUI_IsConsoleActive()){
			CritterCl@ cr = GetMonitorCritter(__MouseX, __MouseY, false);
			string result =
				"Health: \n" +
				"Torso Damage/Burn: " + cr.Param[CR_TORSO_DAMAGE] + "/" + cr.Param[CR_TORSO_BURN] + "\n" +
				"LArm Damage/Burn: " + cr.Param[CR_LEFT_ARM_DAMAGE] + "/" + cr.Param[CR_LEFT_ARM_BURN] + "\n" +
				"RArm Damage/Burn: " + cr.Param[CR_RIGHT_ARM_DAMAGE] + "/" + cr.Param[CR_RIGHT_ARM_BURN] + "\n" +
				"LLeg Damage/Burn: " + cr.Param[CR_LEFT_LEG_DAMAGE] + "/" + cr.Param[CR_LEFT_LEG_BURN] + "\n" +
				"RLeg Damage/Burn: " + cr.Param[CR_RIGHT_LEG_DAMAGE] + "/" + cr.Param[CR_RIGHT_LEG_BURN] + "\n" +
				"Head Damage/Burn: " + cr.Param[CR_HEAD_DAMAGE] + "/" + cr.Param[CR_HEAD_BURN] + "\n" +
				"Internals Damage: " + cr.Param[CR_INTERNALS_DAMAGE] + "\n" +
				"Blood: " + cr.Param[CR_BLOOD] + "/" + cr.Param[CR_MAXBLOOD] + "\n" +
				"Hp: " + getHpPercentage(cr) + "\n" +
				"HeartBeat: " + cr.Param[CR_HEARTBEAT] + "\n";
				
            DrawText( result, __MouseX, __MouseY, __ScreenWidth, __ScreenHeight, COLOR_WHITE, FONT_DEFAULT, 0 );

		}
		
		if(GetMonitorCritter(__MouseX, __MouseY, false) !is null && GetCurrentCursor() == CURSOR_DEFAULT && !GUI_IsConsoleActive()){
			CritterCl@ cr = GetMonitorCritter(__MouseX, __MouseY, false);
			uint8 mode = 0;
			ProtoItem@ armor = cr.GetSlotProto(SLOT_ARMOR, mode);
			
			string result = armor.Armor_FaceCovering ? "Незнакомец" : cr.Name;
            DrawText( result, __MouseX + 20, __MouseY - 15, __ScreenWidth, __ScreenHeight, COLOR_IFACE_GREEN, FONT_DEFAULT, 0 );
		}
		
        // Zoom text
        if( __MapZooming && __SpritesZoomMin != __SpritesZoomMax )
        {
            string@ zoomText = MSG_GAME( STR_ZOOM );
            @zoomText = ReplaceText( zoomText, "%d", "" + int(1.0 / __SpritesZoom * 100.0) );
            @zoomText = ReplaceText( zoomText, "%%", "%" );
            DrawText( zoomText, 0, 0, __ScreenWidth, __ScreenHeight, COLOR_SAND, FONT_BIG, FT_CENTERX | FT_CENTERY );
        }
    }
    else if( layer == 4 )
    {
        GUI_EngineCallback_DrawCursor();
    }
    else if( layer == 100 && __GmapActive )
    {
        // Here you can draw on global map

        // bool  __GmapActive - активна ли глобальная карта и все ли следующие нижеприведенные переменные корректны;
        // bool  __GmapWait   - включен режим ожидания ответа о подтверждении энкаунтера;
        // float __GmapZoom   - текущий масштаб, не забывайте учитывать его при рисовании на карте;
        // int   __GmapOffsetX/Y   - смещение карты от нулевой координаты (верхний-левый угол);
        // int   __GmapGroupCurX/Y - координаты группы игрока;
        // int   __GmapGroupToX/Y  - координаты точки назначения;
        // float __GmapGroupSpeed  - текущая скорость передвижения.
        // Для примера, расчет текущего пикселя группы:
        // x = __GmapGroupX / __GmapZoom + __GmapOffsetX, y = __GmapGroupY / __GmapZoom + __GmapOffsetY.
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Render map function. You can use DrawMap* functions only there. This drawing before 1 iface layer.
void render_map()
{
    //
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out game.
import string getName(int crId) from "rp_names";
import void loadNamesFromServer() from "rp_names";

uint lastId = 0;
void critter_in( CritterCl& cr )
{
	if(cr.IsChosen() && lastId != cr.Id){
		loadNamesFromServer();
		lastId = cr.Id;
	}
	
    // Default colors
    cr.NameColor = COLOR_CRITTER_NAME;
    cr.ContourColor = COLOR_CONTOUR_GREEN;
	
	
	if(!cr.IsChosen()){
		cr.Name = getName(cr.Id);
	}
	cr.NameOnHead = " ";
	/*
	if(cr.IsPlayer()){
		if(cr.Name == "Незнакомец")
			cr.NameOnHead = " ";
		else
			cr.NameOnHead = "";
			
	}*/
}

void critter_out( CritterCl& cr )
{
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something item in/changed/out map.
void item_map_in( ItemCl& item )
{
    GUI_EngineCallback_ItemChanged( true );
}

void item_map_changed( ItemCl& itemNow, ItemCl& itemBefore )
{
    GUI_EngineCallback_ItemChanged( true );
}

void item_map_out( ItemCl& item )
{
    GUI_EngineCallback_ItemChanged( true );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out chosen inventory.
void item_inv_in( ItemCl& item )
{
    GUI_EngineCallback_ItemChanged( false );
}

void item_inv_changed( ItemCl& itemNow, ItemCl& itemBefore )
{
    GUI_EngineCallback_ItemChanged( false );
}

void item_inv_out( ItemCl& item )
{
    GUI_EngineCallback_ItemChanged( false );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message on map.
// By default delay == [TextDelay + message length * 100] ms
bool map_message( string& message, uint16& hexX, uint16& hexY, uint& color, uint& delay )
{
    // Detect radio
    if( color == 0xFFFFFFFE )
        message = "..пшш.." + message + "..пшш..";
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message.
// By default delay == [TextDelay + message length * 100] ms
bool in_message( string& message, int& sayType, uint& critterId, uint& delay )
{	

	if(message == prevReceivedMessage)
	{
		return false;
	}
	prevReceivedMessage = message;
    CritterCl@ cr = GetCritter( critterId );
    if( valid( cr ) && PlayerIgnored( cr ) )
        return false;
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on send message.
bool out_message( string& message, int& sayType )
{
    string cmdPrefix = "~";
    if( message[ 0 ] == cmdPrefix ) // Command
    {
        message[ 0 ] = "";

		if( message == "becomeBald" ){
			RunServerScriptUnsafe("rp_utils@unsafe_changeAppearance", 0, 0, 0, null, null);
			return false;
		}
		
		if( message == "becomeDefault" ){
			RunServerScriptUnsafe("rp_utils@unsafe_changeAppearance", 1, 0, 0, null, null);
			return false;
		}
		
		if( message == "becomeLongHair" ){
			RunServerScriptUnsafe("rp_utils@unsafe_changeAppearance", 2, 0, 0, null, null);
			return false;
		}
		
		if( message == "rememberTargets"){
			RunServerScriptUnsafe("traitors@unsafe_rememberTargets", 0, 0, 0, null, null);
			return false;
		}

		if( message == "sf"){
			RunServerScriptUnsafe("rp_utils@unsafe_sleep", 0, 0, 0, null, null);
			return false;
		}
		
		if( message == "sb"){
			RunServerScriptUnsafe("rp_utils@unsafe_sleep", 1, 0, 0, null, null);
			return false;
		}
		
		if( message == "accessLevel" )
		{
			printAccessLevelString();
			return false;
		}
		
        if( message == "getId" )
        {
            Message("ID: " + GetStrHash(__HardwareId));
            return false;
        }
		
		if( message == "debug" ){
			__CrDebugInfo = !__CrDebugInfo;
			return false;
		}
		
        if( message == "ignorelist" )
        {
            InitIgnoreList();
            Message( "Ignore list refreshed." );
            return false;
        }

        if( message == "globalmap" )
        {
            RunServerScriptUnsafe( "nopvp_maps@unsafe_CritterToGlobal", 0, 0, 0, null, null );
            return false;
        }

		if( substring(message, 0, findFirst(message, " ")) == "setDescription"){
			string@ str = substring(message, findFirst(message, " " ) + 1, message.length());
			
			RunServerScriptUnsafe("rp_utils@unsafe_setLexems", 0, 0, 0, str, null);		
			return false;
		}
		
		
        if( message.length() > 7 && substring( message, 0, 7 ) == "ignore " )
        {
            IgnorePlayer( cmdPrefix + message );
            InitIgnoreList();
            return false;
        }
		
		if( substring(message, 0, findFirst(message, " ")) == "hardBan"){
			int id = 0;
			StrToInt(substring(message, findFirst(message, " "), message.length()), id);
			RunServerScriptUnsafe("rp_utils@unsafe_hardBan", id, 0, 0, null, null);
			return false;
		}

		if( substring(message, 0, findFirst(message, " ")) == "setAccessLevel"){
			int id = 0;
			string@[] strings = splitEx(message, " ");
			StrToInt( strings[1], id);
			RunServerScriptUnsafe("rp_utils@unsafe_setAccessLevel", id, 0, 0, strings[2], null);
			return false;
		}
		
		if( substring(message, 0, findFirst(message, " ")) == "whitelist"){
			int id = 0;
			StrToInt(substring(message, findFirst(message, " "), message.length()), id);
			RunServerScriptUnsafe("rp_utils@unsafe_whiteList", id, 0, 0, null, null);
			return false;
		}
		
		if( substring(message, 0, findFirst(message, " ")) == "dewhitelist"){
			int id = 0;
			StrToInt(substring(message, findFirst(message, " "), message.length()), id);
			RunServerScriptUnsafe("rp_utils@unsafe_deWhiteList", id, 0, 0, null, null);
			return false;
		}
        string separator = "#";
        string result = CustomCall( "Command" + separator + message, separator );
        if( result == "UNKNOWN" )
        {
            Message( "Unknown command." );
        }
        else if( result.length() > 0 )
        {
            string@[] @ msg = splitEx( result, separator );
            for( uint i = 0; i < msg.length(); i++ )
                Message( ReplaceText( result, "<", "<" + cmdPrefix ) );
        }

        return false;
    }
	CritterCl@ chosen = GetChosen();
    if( sayType == SAY_NORM )
    {
        if( message.length() > 2 && ( message[ 0 ] == "/" || message[ 0 ] == "." ) )
        {
            string ch = message[ 1 ];
            if(     ch == "к" || ch == "К" || ch == "s" || ch == "S" )
                sayType = SAY_SHOUT;
            else if( ch == "э" || ch == "Э" || ch == "e" || ch == "E" )
                sayType = SAY_EMOTE;
            else if( ch == "ш" || ch == "Ш" || ch == "w" || ch == "W" )
                sayType = SAY_WHISP;
            else if( ch == "с" || ch == "С" || ch == "$" )
                sayType = SAY_SOCIAL;
            else if( ch == "р" || ch == "Р" || ch == "r" || ch == "R" )
                sayType = SAY_RADIO;

            if( sayType != SAY_NORM )
            {
                message[ 0 ] = "";
                message[ 0 ] = "";
                while( message[ 0 ] == " " )
                    message[ 0 ] = "";
            }
        }
        else if(         // RegExp: [*]([^*].*[^*])[*]
            message.length() >= 4 && message[ 0 ] == "*" && message[ 1 ] != "*" &&
            message[ message.length() - 2 ] != "*" && message[ message.length() - 1 ] == "*" )
        {
            sayType = SAY_EMOTE;
            message = substring( message, 1, message.length() - 2 );
        }
    }

    bool result = false;
    for( uint i = 0, j = message.length(); i < j; i++ )
    {
        if( message[ i ] != " " )
        {
            result = true;
            break;
        }
    }
    if( sayType == SAY_NORM )
    {
        if( findFirst( message, "*" ) != -1 )
        {
            uint countfirst = findFirst( message, "*" );
            if( findFirst( message, "*", countfirst ) != -1 )
            {
                string@[] strs;
                strs = split( message, "*" );
				for(uint i = 1; i < strs.length(); ++i )
				{
				strs[ i ] = "|0xFFBB33CC **" + strs[ i ] + "** |0xF8F993 ";
				++i;
				}
                message = join( strs, "" );
				//message += "\n";
            }
        }
		if(!chosen.IsKnockout() && !chosen.IsDead()){
			RunServerScriptUnsafe("rp_utils@unsafe_interceptTalking", 0, 0, 0, message, null);
			return false;
		}
    }
	
	if( sayType == SAY_RADIO ){
		ItemCl@ radio = chosen.GetItem(PID_RADIO, SLOT_HAND1);

		if(!valid(radio))
		{
			sayType = SAY_WHISP;
		}
	}
	
	if( sayType == SAY_RADIO ){
		RunServerScriptUnsafe("logger@unsafe_LoggerCall", RADIOLOG, 0, 0, message, null);
	}
	
	if( chosen.IsDead() )
	{
		Message("Мертвые не разговаривают.");
		return false;
	}
	
	if( chosen.IsKnockout() )
	{
		RunServerScriptUnsafe("rp_utils@unsafe_SayInKnockout", sayType, 0, 0, message, null);
		return false;
	}
	
    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// To-hit chance.
int to_hit( CritterCl& chosen, CritterCl& target, ProtoItem& weapon, uint8 weaponMode )
{
    int use         = _WeaponModeUse( weaponMode );
    int hitLocation = _WeaponModeAim( weaponMode );
    if( use > 2 )
        return 0;

    if( target.IsDead() )
        return 0;
    if( !chosen.IsLife() )
        return 0;

    ItemCl@    realWeapon = _CritGetItemHand( chosen );
    ProtoItem@ ammo = null;

    if( valid( realWeapon ) && _WeaponRound( weapon, use ) > 0 )
    {
        if( realWeapon.AmmoCount == 0 )
            return 0;
        @ammo = GetProtoItem( realWeapon.AmmoPid );
    }

    uint skillNum = _WeaponSkill( weapon, use );
    int  wpnMaxDist = _WeaponMaxDist( weapon, use );
    if( skillNum == SK_THROWING )
        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] + 2 * chosen.Perk[ PE_HEAVE_HO ] ) );

    int dist = GetCrittersDistantion( chosen, target );
    if( dist > wpnMaxDist )
        return 0;

    int toHit = int(chosen.Skill[ skillNum ]);
    int weaponPerk = weapon.Weapon_Perk;
    int blockers = 0;

    if( skillNum != SK_UNARMED && skillNum != SK_MELEE_WEAPONS )
    {
        // Ranged attack modifiers
        int distmod1 = 2; // Used for initial weapon bonus
        int distmod2 = 0; // Minimal distance
        if( weaponPerk == WEAPON_PERK_LONG_RANGE )
            distmod1 = 4;
        else if( weaponPerk == WEAPON_PERK_SCOPE_RANGE )
        {
            distmod1 = 5;
            distmod2 = 8;
        }

        int perception = chosen.Stat[ ST_PERCEPTION ];
        int acc = dist;

        if( dist < distmod2 )
            acc += distmod2;
        else
        {
            if( chosen.IsPlayer() )
                acc -= ( perception - 2 ) * distmod1;               // we want to keep it, because fo2238 might use it to display NPCs chance (via possessing)
            else
                acc -= perception * distmod1;
        }

        if( -2 * perception > acc )
            acc = -2 * perception;

        acc -= 2 * chosen.Perk[ PE_SHARPSHOOTER ];

        if( acc >= 0 )
        {
            if( chosen.Damage[ DAMAGE_EYE ] != 0 )
                acc *= -12;
            else
                acc *= -4;
        }
        else
            acc *= -4;

        toHit += acc;

        blockers = GetCrittersPath( chosen.HexX, chosen.HexY, target.HexX, target.HexY, 0.0f, dist, FIND_LIFE, null );
        if( !target.IsKnockout() )
            blockers--;
        toHit -= 10 * blockers;
    } // End range modifiers

    if( !( weapon.Weapon_IsUnarmed ) && chosen.Trait[ TRAIT_ONE_HANDER ] != 0 && valid( realWeapon ) )
        toHit += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );

    int handlingStrength = chosen.Stat[ ST_STRENGTH ];
    int reqStrength = weapon.Weapon_MinStrength;
    if( chosen.Perk[ PE_WEAPON_HANDLING ] != 0 )
        handlingStrength += 3;
    if( handlingStrength < reqStrength )
        toHit -= ( reqStrength - handlingStrength ) * 20;
    if( weaponPerk == WEAPON_PERK_ACCURATE )
        toHit += 20;

    int acmod = target.Stat[ ST_ARMOR_CLASS ];
    if( valid( ammo ) )
        acmod += ammo.Ammo_ACMod;
    if( acmod > 0 )
        toHit -= acmod;
    // TODO: tohit += 15 if target is multihex
    // TODO: light penalty

    if( chosen.Damage[ DAMAGE_EYE ] != 0 )
        toHit -= 25;
    if( chosen.Perk[ PE_VAMPIRE_ACCURACY ] != 0 && IS_NIGHT( __Hour ) )
        toHit += 13;
    if( target.IsKnockout() )
        toHit += 40;
    toHit += target.GetMultihex() * 15;

    int hitMod = GetHitAim( hitLocation );
    if( skillNum == SK_MELEE_WEAPONS || skillNum == SK_UNARMED )
        hitMod /= 2;
    toHit -= hitMod;
    toHit = CLAMP( toHit, 5, 95 );

    return toHit;
}

uint GetHitAim( int hitLocation )
{
    switch( hitLocation )
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __HitAimTorso;
    case HIT_LOCATION_EYES:
        return __HitAimEyes;
    case HIT_LOCATION_HEAD:
        return __HitAimHead;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __HitAimArms;
    case HIT_LOCATION_GROIN:
        return __HitAimGroin;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __HitAimLegs;
    default:
        break;
    }
    return 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Override aim location set by player through targetting screen or simple click on target.
void hit_aim( uint8& aim )
{
	CritterCl@ chosen = GetChosen();
	
	if(valid(chosen) )
	{
		ItemCl@ item = _CritGetItemHand(chosen);
		uint16 ammoRound = 0;
		if(valid(item)){
			uint8 mode = item.Mode;
			ammoRound = _WeaponRound( item.Proto, mode );
		}
		if(ammoRound > 1){
			aim = HIT_LOCATION_NONE;
		}else{
			aim = chosen.Param[CR_CURRENT_AIM];
		}
	}
	
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Combat results.
void combat_result( uint[]& data )
{
    uint datalen = data.length();
    if( datalen == 0 )
        return;
    if( data[ 0 ] != datalen )
        return;

    uint current = 1;

    while( current < datalen )
    {
        int        damage  = -1;
        uint       effect =  0;
        uint       loc    =  0;
        int        message = -1;

        uint       mode = data[ current++ ];
        uint       who  = data[ current++ ];
        uint       who2;
        CritterCl@ originalTarget;

        CritterCl@ cr         = GetCritter( who );
        CritterCl@ chosen     = GetChosen();
        CritterCl@ trueTarget = null;

        bool       self = ( who == GetChosen().Id );

        string     name = "error0";
        if( valid( cr ) )
        {
            if( !self )
                name = cr.Name;
            else
                name = GetMsgStr( TEXTMSG_COMBAT, chosen.Stat[ ST_GENDER ] == GENDER_MALE ? 506 : 556 );
        }

        uint offset;
        if( self )
        {
            if( cr.Stat[ ST_GENDER ] == GENDER_MALE )
                offset = 506;
            else
                offset = 556;
        }
        else
        {
            if( cr.Stat[ ST_GENDER ] == GENDER_MALE )
                offset = 606;
            else
                offset = 706;
        }

        string result;

        // reading and preparing the data:
        switch( mode )
        {
        case CMSG_CRIT_MISS:
            effect = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + 8 );
            result = ReplaceText( result, "%s", name );
            break;
        case CMSG_CRIT_MISS_DAMAGE:
            effect = data[ current++ ];
            damage = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 28 : 27 ) );
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_HIT:
        case CMSG_HIT_DEAD:
            damage = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 7 : ( damage != 0 ? 17 : 21 ) ) );
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_AIMED_HIT:
        case CMSG_AIMED_HIT_DEAD:
            loc    = data[ current++ ];
            damage = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 6 : ( damage != 0 ? 16 : 20 ) ) );
            result = ReplaceText( result, "%s", name );
            result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_HIT:
            damage  = data[ current++ ];
            effect  = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 14 : ( damage != 0 ? 18 : 22 ) ) );
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_AIMED_HIT:
            loc     = data[ current++ ];
            damage  = data[ current++ ];
            effect  = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 5 : ( damage != 0 ? 15 : 19 ) ) );
            result = ReplaceText( result, "%s", name );
            result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_HIT_DEAD:
            damage  = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 14 : ( damage != 0 ? 18 : 22 ) ) );
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_AIMED_HIT_DEAD:
            loc     = data[ current++ ];
            damage  = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 5 : ( damage != 0 ? 15 : 19 ) ) );
            result = ReplaceText( result, "%s", name );
            result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_OOPS:
            who2 = data[ current++ ];           // who2 was hit instead of who
            // +2 "... was hit instead of you!"
            // +3 "... was hit instead of ...!"
            @trueTarget = GetCritter( who2 );
            if( self )
            {
                // It was original target
                result = GetMsgStr( TEXTMSG_COMBAT, cr.Stat[ ST_GENDER ] == GENDER_MALE ? 608 : 708 );
                string nameTrue = "error1";
                if( valid( trueTarget ) )
                    nameTrue = trueTarget.Name;
                result = ReplaceText( result, "%s", nameTrue );
            }
            else
            {
                // It was not original target
                result = GetMsgStr( TEXTMSG_COMBAT, offset + 3 );
                if( who2 == GetChosen().Id )
                {
                    result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, chosen.Stat[ ST_GENDER ] == GENDER_MALE ? 506 : 556 ) );
                }
                else
                {
                    string nameTrue = "error1";
                    if( valid( trueTarget ) )
                        nameTrue = trueTarget.Name;
                    result = ReplaceText( result, "%s", nameTrue );
                }
                result = ReplaceText( result, "%s", name );
            }
            break;
        case CMSG_MISS:
            result = GetMsgStr( TEXTMSG_COMBAT, offset + 9 );
            result = ReplaceText( result, "%s", name );
            break;
        case CMSG_HIT_RANDOMLY:
            result  = GetMsgStr( TEXTMSG_COMBAT, offset + 9 );
            result  = ReplaceText( result, "%s", name );
            result += GetMsgStr( TEXTMSG_COMBAT, 108 ) + GetMsgStr( TEXTMSG_COMBAT, offset - 306 + 20 );
        default:
            break;
        }

        bool isVerbose = ( __CombatMessagesType == 0 );
        string@[] ext;

        if( message != -1 && isVerbose )       // Must be critical hit
        {
            result += GetMsgStr( TEXTMSG_COMBAT, message );
        }
        else if( effect != 0 )
        {
            offset -= 306;
            if( mode > CMSG_CRIT_MISS_DAMAGE )           // Hit flags
            {
                if( FLAG( effect, HF_KNOCKOUT ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 0 ) );
                if( FLAG( effect, HF_KNOCKDOWN ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 1 ) );
                if( FLAG( effect, HF_CRIPPLED_LEFT_LEG ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 2 ) );
                if( FLAG( effect, HF_CRIPPLED_RIGHT_LEG ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 3 ) );
                if( FLAG( effect, HF_CRIPPLED_LEFT_ARM ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 4 ) );
                if( FLAG( effect, HF_CRIPPLED_RIGHT_ARM ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 5 ) );
                if( FLAG( effect, HF_BLINDED ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 6 ) );
                // if(FLAG(effect, HF_DEATH))              ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset     )); // This is handled elsewhere
                // if(FLAG(effect, HF_ON_FIRE))            ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 10)); // Not used
                if( FLAG( effect, HF_BYPASS_ARMOR ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 11 ) );
                if( FLAG( effect, HF_DROPPED_WEAPON ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 14 ) );
                if( FLAG( effect, HF_LOST_NEXT_TURN ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 15 ) );
                if( FLAG( effect, HF_RANDOM ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 21 ) );
            }
            else
            {
                if( FLAG( effect, MF_KNOCKED_DOWN ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset +  1 ) );
                // if(FLAG(effect, MF_ON_FIRE))              ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 10)); // Not used
                if( FLAG( effect, MF_WEAPON_EXPLODED ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 12 ) );
                if( FLAG( effect, MF_WEAPON_DESTROYED ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 13 ) );
                if( FLAG( effect, MF_WEAPON_DROPPED ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 14 ) );
                if( FLAG( effect, MF_LOST_NEXT_TURN ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 15 ) );
                if( FLAG( effect, MF_HIT_SELF ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 16 ) );
                if( FLAG( effect, MF_LOST_REST_OF_AMMO ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 17 ) );
                if( FLAG( effect, MF_FIRED_DUD_SHOT ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 18 ) );
                if( FLAG( effect, MF_HURT_SELF ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 19 ) );
                // if(FLAG(effect, MF_HIT_RANDOMLY))         ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 20)); // This is handled elsewhere
                if( FLAG( effect, MF_CRIPPLED_RANDOM_LIMB ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 21 ) );
                if( FLAG( effect, MF_WAS_KILLED ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset +  7 ) );
            }
            offset += 306;
        }

        if( 8 <= mode && mode <= 11 && ( !isVerbose || message == -1 ) )
            ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 7 - 306 ) );

        for( uint m = 0, n = ext.length(); m < n; m++ )
        {
            if( m == n - 1 )
                result += GetMsgStr( TEXTMSG_COMBAT, 108 );
            else
                result += ", ";

            result += ext[ m ];
        }

        result += ".";

        Message( result, FOMB_COMBAT_RESULT );

        if( 8 <= mode && mode <= 11 && isVerbose && message != -1 )
            Message( name + " " + GetMsgStr( TEXTMSG_COMBAT, offset + 7 - 306 ) + ".", FOMB_COMBAT_RESULT );

        // On head indication
        if( __DamageHitDelay > 0 && damage > 0 )
            MapMessage( "-" + damage, cr.HexX, cr.HexY, __DamageHitDelay, 0xFFC80000, true, Random( -5, 5 ), -20 );
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Generic description. Descriptions type look in _client_defines.fos, Generic descriptions types.
// int& offsX, int& offsY - offsets of text, by default is zero.
string generic_description( int descType, int& offsX, int& offsY )
{
    CritterCl@ chosen = GetChosen();
    if( not valid( chosen ) )
        return "";
    string result;

    if( descType == DESC_INVENTORY_MAIN )
    {
        result += chosen.Name        + "\n";
        result += "---------------------\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_STRENGTH ) )   + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_PERCEPTION ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_ENDURANCE ) )  + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_CHARISMA ) )   + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_INTELLECT ) )  + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_AGILITY ) )    + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_LUCK ) )       + "\n";
        result += "---------------------\n";

        ItemCl@ weaponMain = chosen.GetItem( 0, SLOT_HAND1 );
        if( valid( weaponMain ) )
        {
            int use = _WeaponModeUse( weaponMain.Mode );
            if( use > 2 )
                use = 0;

            result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( weaponMain ) ) + "\n";

            if( weaponMain.GetType() == ITEM_TYPE_WEAPON )
            {
                result += GetMsgStr( TEXTMSG_GAME, STR_INV_DMG ) + " ";
                result += _WeaponDmgMin( weaponMain.Proto, use ) + "-";
                int wpnMaxDmg = _WeaponDmgMax( weaponMain.Proto, use );
                if( _WeaponIsHtHAttack( weaponMain.Proto, use ) )
                    wpnMaxDmg += chosen.Stat[ ST_MELEE_DAMAGE ];
                result += wpnMaxDmg;

                if( _WeaponMaxDist( weaponMain.Proto, use ) > 1 )
                {
                    result += " " + GetMsgStr( TEXTMSG_GAME, STR_INV_DIST ) + " ";
                    int wpnMaxDist = _WeaponMaxDist( weaponMain.Proto, use );
                    if( _WeaponSkill( weaponMain.Proto, use ) == SK_THROWING )
                        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] + 2 * chosen.Perk[ PE_HEAVE_HO ] ) );
                    result += wpnMaxDist;
                }
                result += "\n";

                if( weaponMain.Proto.Weapon_MaxAmmoCount > 0 )
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO ) + " ";
                    result += weaponMain.AmmoCount            + "/";
                    result += weaponMain.Proto.Weapon_MaxAmmoCount  + " ";
                    result += GetMsgStr( TEXTMSG_GAME, STR_CALIBER( weaponMain.Proto.Weapon_Caliber ) );
                }
                result += "\n";
            }
            else
            {
                result += "\n\n";
            }
        }
        else
        {
            // Unarmed
            uint8      mode = 0;
            ProtoItem@ unarmed = chosen.GetSlotProto( SLOT_HAND1, mode );
            result += GetMsgStr( TEXTMSG_GAME, STR_INV_NO_ITEM )     + "\n";
            result += GetMsgStr( TEXTMSG_GAME, STR_INV_UNARMED_DMG ) + " ";
            result += _WeaponDmgMin( unarmed, _WeaponModeUse( mode ) ) + "-";
            result += ( _WeaponDmgMax( unarmed, _WeaponModeUse( mode ) ) + chosen.Stat[ ST_MELEE_DAMAGE ] );
            result += "\n\n";
        }
        result += "---------------------\n";

        ItemCl@ weaponExt = chosen.GetItem( 0, SLOT_HAND2 );
        if( valid( weaponExt ) )
        {
            int use = _WeaponModeUse( weaponExt.Mode );
            if( use > 2 )
                use = 0;

            result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( weaponExt ) ) + "\n";

            if( weaponExt.GetType() == ITEM_TYPE_WEAPON )
            {
                result += GetMsgStr( TEXTMSG_GAME, STR_INV_DMG ) + " ";
                result += _WeaponDmgMin( weaponExt.Proto, use )  + "-";
                int wpnMaxDmg = _WeaponDmgMax( weaponExt.Proto, use );
                if( _WeaponIsHtHAttack( weaponExt.Proto, use ) )
                    wpnMaxDmg += chosen.Stat[ ST_MELEE_DAMAGE ];
                result += wpnMaxDmg;
                if( _WeaponMaxDist( weaponExt.Proto, use ) > 1 )
                {
                    result += " " + GetMsgStr( TEXTMSG_GAME, STR_INV_DIST ) + " ";
                    int wpnMaxDist = _WeaponMaxDist( weaponExt.Proto, use );
                    if( _WeaponSkill( weaponExt.Proto, use ) == SK_THROWING )
                        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] + 2 * chosen.Perk[ PE_HEAVE_HO ] ) );
                    result += wpnMaxDist;
                }
                result += "\n";

                if( weaponExt.Proto.Weapon_MaxAmmoCount > 0 )
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO ) + " ";
                    result += weaponExt.AmmoCount             + "/";
                    result += weaponExt.Proto.Weapon_MaxAmmoCount   + " ";
                    result += GetMsgStr( TEXTMSG_GAME, STR_CALIBER( weaponExt.Proto.Weapon_Caliber ) );
                }
                result += "\n";
            }
            else
            {
                result += "\n\n";
            }
        }
        else
        {
            // Unarmed
            uint8      mode = 0;
            ProtoItem@ unarmed = chosen.GetSlotProto( SLOT_HAND2, mode );
            result += GetMsgStr( TEXTMSG_GAME, STR_INV_NO_ITEM )     + "\n";
            result += GetMsgStr( TEXTMSG_GAME, STR_INV_UNARMED_DMG ) + " ";
            result += _WeaponDmgMin( unarmed, _WeaponModeUse( mode ) ) + "-";
            result += ( _WeaponDmgMax( unarmed, _WeaponModeUse( mode ) ) + chosen.Stat[ ST_MELEE_DAMAGE ] );
            result += "\n\n";
        }

        result += GetMsgStr( TEXTMSG_GAME, STR_INV_TOTAL_WEIGHT ) + " ";
        result += ( chosen.ItemsWeight() / 1000 ) + "/";
        result += ( chosen.Stat[ ST_CARRY_WEIGHT ] / 1000 ) + ".";
    }
    else if( descType == DESC_INVENTORY_SPECIAL )
    {
        offsX = 23;
        result += "\n\n";
        result += chosen.Stat[ ST_STRENGTH ]   + "\n";
        result += chosen.Stat[ ST_PERCEPTION ] + "\n";
        result += chosen.Stat[ ST_ENDURANCE ]  + "\n";
        result += chosen.Stat[ ST_CHARISMA ]   + "\n";
        result += chosen.Stat[ ST_INTELLECT ]  + "\n";
        result += chosen.Stat[ ST_AGILITY ]    + "\n";
        result += chosen.Stat[ ST_LUCK ];
    }
    else if( descType == DESC_INVENTORY_STATS )
    {
        offsX = 39;
        result += "\n\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_HP ) + " ";
        result += chosen.Stat[ ST_CURRENT_HP ] + "/" + chosen.Stat[ ST_MAX_LIFE ] + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_AC ) + " ";
        result += chosen.Stat[ ST_ARMOR_CLASS ] + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_NORMAL ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_LASER )  + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_FIRE )   + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_PLASMA ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_EXPLODE );
    }
    else if( descType == DESC_INVENTORY_RESIST )
    {
        offsX = 103;
        result += "\n\n\n\n";
        result += chosen.Stat[ ST_NORMAL_ABSORB ]  + "/" + chosen.Stat[ ST_NORMAL_RESIST ]  + "%\n";
        result += chosen.Stat[ ST_LASER_ABSORB ]   + "/" + chosen.Stat[ ST_LASER_RESIST ]   + "%\n";
        result += chosen.Stat[ ST_FIRE_ABSORB ]    + "/" + chosen.Stat[ ST_FIRE_RESIST ]    + "%\n";
        result += chosen.Stat[ ST_PLASMA_ABSORB ]  + "/" + chosen.Stat[ ST_PLASMA_RESIST ]  + "%\n";
        result += chosen.Stat[ ST_EXPLODE_ABSORB ] + "/" + chosen.Stat[ ST_EXPLODE_RESIST ] + "%";
    }

    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Item description. Look types look in _client_defines.fos, Item look types.
string item_description( ItemCl& item, int lookType )
{
    // Default error text
    if( not IsMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) + ( lookType != ITEM_LOOK_ONLY_NAME ? 1 : 0 ) ) )
        return GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK_NOTHING );

    string result;

    // Car on world map
    if( lookType == ITEM_LOOK_WM_CAR )
    {
        string fuel = GetMsgStr( TEXTMSG_GAME, STR_INV_CAR_FUEL );
        fuel = ReplaceText( fuel, "VALUE",     item.Charge / 100 );
        fuel = ReplaceText( fuel, "MAX_VALUE", item.Proto.Car_TankVolume / 100 );
        string deterioration = GetMsgStr( TEXTMSG_GAME, STR_INV_CAR_DETERIORATION );
        deterioration = ReplaceText( deterioration, "VALUE", item.Deterioration * 100 / item.Proto.Car_MaxDeterioration );
        result = fuel + "\n" + deterioration;
    }
    // Short info
    else if( lookType == ITEM_LOOK_ONLY_NAME )
    {
        result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK ), "NAME", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
    }
    // Full info
    else
    {
		if(item.Lexems != ""){
			result += item.Lexems;
			result += "\n";
		}
        if( lookType == ITEM_LOOK_INVENTORY )
            result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) + "\n";

        if( item.GetProtoId() == PID_HOLODISK && item.HolodiskNumber != 0 )
            result += GetMsgStr( TEXTMSG_HOLO, STR_HOLO_INFO_NAME( item.HolodiskNumber ) );
        else
            result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) + 1 );

        if( lookType != ITEM_LOOK_MAP )
        {
            // Weight
            result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight * item.GetCount() );

            // Ammo load
            if( item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_MaxAmmoCount > 0 )
            {
                result += "\n";
                string str = GetMsgStr( TEXTMSG_GAME, STR_INV_HAS_SHOTS );
                str = ReplaceText( str, "VALUE",     item.AmmoCount );
                str = ReplaceText( str, "MAX_VALUE", item.Proto.Weapon_MaxAmmoCount );
                str = ReplaceText( str, "AMMO",      GetMsgStr( TEXTMSG_GAME, STR_CALIBER( item.Proto.Weapon_Caliber ) ) );
				result += "Точность: " + item.Proto.Weapon_Accurate + "\n";
				result += "Отдача: " + item.Proto.Weapon_Recoil + "\n";
				result += "Тип оружия: " + item.Proto.Weapon_Type + "\n";
				result += "Тип пушки: " + item.Proto.Weapon_GunType + "\n";
                result += str;
            }
			if(item.GetType() == ITEM_TYPE_ARMOR){
				result += "\n";
				result += "Класс брони головы: " + item.Proto.Armor_Class_Head + "\n";
				result += "Класс брони торса: " + item.Proto.Armor_Class_Torso + "\n";
				result += "Класс брони рук: " + item.Proto.Armor_Class_Hands + "\n";
				result += "Класс брони ног: " + item.Proto.Armor_Class_Legs + "\n";
				result += "Гибкая? : " + item.Proto.Armor_IsFlexible + "\n";
			}
			if(item.GetType() == ITEM_TYPE_AMMO && !item.Proto.Item_IsMagazine){
				result += "\n";
				result += "Убойная сила: " + item.Proto.Ammo_Force + "\n";
				result += "Класс бронепробиваемости: " + item.Proto.Ammo_APLevel + "\n";
				result += "Потеря бронепробиваемости каждые " + item.Proto.Ammo_APLoss + " метров\n";
			}
			
			if(item.GetType() == ITEM_TYPE_AMMO && item.Proto.Item_IsMagazine)
			{
				result += "\n";
				result += "Заряжено патронов: " + item.AmmoCount;
			}
            // Deterioration
            if( item.IsDeteriorable() )
            {
                uint8  brokenFlags    = item.BrokenFlags;
                uint8  brokenCount    = item.BrokenCount;
                uint16 deterioration = item.Deterioration;

                // Broken level, procent
                result += "\n";
                if( FLAG( brokenFlags, BI_NOTRESC ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_NO_RESC );
                else if( FLAG( brokenFlags, BI_LOWBROKEN ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_LOW );
                else if( FLAG( brokenFlags, BI_NORMBROKEN ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_NORM );
                else if( FLAG( brokenFlags, BI_HIGHBROKEN ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_HIGH );
                else
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_PROCENT ), "VALUE", deterioration * 100 / MAX_DETERIORATION );

                // Service
                if( FLAG( brokenFlags, BI_SERVICE ) )
                    result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_SERVICE );

                // Service ext
                if( FLAG( brokenFlags, BI_SERVICE_EXT ) )
                    result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_SERVICE_EXT );

                // Broken count
                CritterCl@ chosen = GetChosen();
                if( valid( chosen ) && chosen.Perk[ PE_MR_FIXIT ] != 0 )
                    result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_COUNT ), "VALUE", brokenCount );
            }

            // Key id
            if( item.GetType() == ITEM_TYPE_KEY )
                result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_INV_KEY_NUMBER ), "KEY_ID", item.LockerId );
        }
    }

    // Format tags
    if( item.Lexems != "" )
        return FormatTags( result, item.Lexems );
    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Critter description. Look types look in _client_defines.fos, Critter look types.
string critter_description( CritterCl& cr, int lookType )
{
    string result;
    int    gender = cr.Stat[ ST_GENDER ];
	uint8 mode = 0;
	ProtoItem@ armorProto = cr.GetSlotProto(SLOT_ARMOR, mode);
	
    // Player
    if( cr.IsPlayer() )
    {
        // Only name
        if( lookType == CRITTER_ONLY_NAME )
        {
            result = cr.Name;             // No change
        }
        // Short info
        else if( lookType == CRITTER_LOOK_SHORT /*&& !*/ )
        {
			if(!armorProto.Armor_FaceCovering)
				result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK1( gender ) );
            result += cr.Name;
            result += ".";
        }
        // Full info
        else// if ( !armorProto.Armor_FaceCovering)
        {
			if(!armorProto.Armor_FaceCovering){

				result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK1( gender ) );
	
				// Age
				uint ageStr = GetMsgStrNumUpper( TEXTMSG_GAME, STR_CRIT_LOOK_AGE( gender, cr.Stat[ ST_AGE ] ) );
				if( ageStr != 0 )
					result += GetMsgStr( TEXTMSG_GAME, ageStr );
				else
					result += cr.Name;
			}else{
					result += cr.Name;
			}
            result += ".";
        }
    }
    // Npc
    else
    {
        uint   dlgId = cr.Stat[ ST_DIALOG_ID ];
        uint16 npcPid = cr.Pid;
        bool   defaultText = false;

        if( lookType == CRITTER_ONLY_NAME )
        {
            result = GetMsgStr( TEXTMSG_DLG, STR_NPC_NAME( dlgId, npcPid ) );
        }
        // Short info
        else if( lookType == CRITTER_LOOK_SHORT )
        {
            if( cr.IsLife() && IsMsgStr( TEXTMSG_DLG, STR_NPC_INFO_LIFE( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_INFO_LIFE( dlgId, npcPid ) );
            else if( cr.IsKnockout() && IsMsgStr( TEXTMSG_DLG, STR_NPC_INFO_KO( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_INFO_KO(  dlgId, npcPid ) );
            else if( cr.IsDead() && IsMsgStr( TEXTMSG_DLG, STR_NPC_INFO_DEAD( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_INFO_DEAD( dlgId, npcPid ) );
            else
                defaultText = true;
        }
        // Full info
        else
        {
            if( cr.IsLife() && IsMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_LIFE( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_LIFE( dlgId, npcPid ) );
            else if( cr.IsKnockout() && IsMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_KO( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_KO(  dlgId, npcPid ) );
            else if( cr.IsDead() && IsMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_DEAD( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_DEAD( dlgId, npcPid ) );
            else
                defaultText = true;
        }

        if( defaultText )
        {
            // Check standart text
            if( IsMsgStr( TEXTMSG_DLG, STR_NPC_NAME( dlgId, npcPid ) ) )
            {
                if( cr.IsLife() )
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_LIFE ), "NAME", GetMsgStr( TEXTMSG_DLG, STR_NPC_NAME( dlgId, npcPid ) ) );
                else if( cr.IsKnockout() )
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_KO ), "NAME", GetMsgStr( TEXTMSG_DLG, STR_NPC_NAME( dlgId, npcPid ) ) );
                else if( cr.IsDead() )
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_DEAD ), "NAME", GetMsgStr( TEXTMSG_DLG, STR_NPC_NAME( dlgId, npcPid ) ) );
            }
            // Set default text
            else
            {
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_NOTHING );
            }
        }
    }

    // Additional description
    if( lookType == CRITTER_LOOK_FULL )
    {
        if( result.length() > 0 && result[ result.length() - 1 ] != "." )
            result += ".";
        result += " ";

        ItemCl@ item = cr.GetItem( 0, SLOT_HAND1 );
		ItemCl@ secondItem = cr.GetItem(0, SLOT_HAND2 );
		ItemCl@ armor = cr.GetItem(0, SLOT_ARMOR);
		
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WHO( gender ) );

        int hp_proc = getHpPercentage(cr);
        if( cr.IsDead() )
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 0 ) );
        else if( hp_proc < 34 )
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 1 ) );
        else if( hp_proc < 67 )
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 2 ) );
        else if( hp_proc < 100 )
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 3 ) );
        else
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 4 ) );
		
        if( _CritIsInjured( cr ) )
        {
            if( valid( item ) )
                result += ", ";
            else
                result += GetMsgStr( TEXTMSG_GAME, STR_AND );
        
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_LIMBS( gender, false ) );
        }
        
        if( valid( item ) )
        {
            if( item.GetType() == ITEM_TYPE_WEAPON )
            {
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WEAP );
                result = ReplaceText( result, "WEAPON", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
            }
            else
            {
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_MISC );
                result = ReplaceText( result, "MISC", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
            }
			if(valid(secondItem)){
				result += GetMsgStr( TEXTMSG_GAME, 12543 );
				result = ReplaceText( result, "ITEM2", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( secondItem ) ) );
			}
			result += ".";
        }else if(valid(secondItem))
		{
			result += ",";

			result += GetMsgStr( TEXTMSG_GAME, 12545 );
			result = ReplaceText( result, "ITEM", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( secondItem ) ) );
		}
		
		if( valid(armor) )
		{
			result += ",";

			result += GetMsgStr( TEXTMSG_GAME, 12544 );
			result = ReplaceText( result, "ARMOR", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( armor ) ) );
		}

		if(cr.Lexems != ""){
		    if( result.length() > 0 && result[ result.length() - 1 ] != "." )
            result += ",";
			if(valid(armor)){
				if( !armor.Proto.Armor_FaceCovering){
					result += " " + cr.Lexems + ".";
				}else{
					result += " лицо скрыто капюшоном.";
				}
			}else{
				result += " " + cr.Lexems + ".";
				
				CritterCl@ chosen = GetChosen();
				
				if( chosen.Param[CR_BEST_FRIEND] == int( cr.Id ) )
				{
					result += ".|" + COLOR_BLUE + "  Это твой лучший друг.|" + COLOR_TEXT;
				}
				
				if( chosen.Param[CR_LOVE] == int( cr.Id ) )
				{
					result += ".|" + COLOR_PINK + "  Ты влюблен в этого человека.|" + COLOR_TEXT;
				}
				
				if( chosen.Param[CR_ENEMY] == int( cr.Id ) )
				{
					result += ".|" + COLOR_DRED + "  Это твой заклятый враг.|" + COLOR_TEXT;
				}
				
				if( chosen.Param[CR_CURRENT_ROLE] == ROLE_THUG && cr.Param[CR_CURRENT_ROLE] == ROLE_THUG  )
				{
					result += ".|" + COLOR_DGREEN + "  Это твой собрат по ремеслу.|" + COLOR_TEXT;
				}
				
			}
		}
		
		if(cr.Param[ST_HANDCUFFS] == 1){
			if( result.length() > 0 && result[ result.length() - 1 ] != "." )
				result += ".";
			result += " Руки связаны веревкой.";
		}else if(cr.ParamBase[ST_HANDCUFFS] > 100){
			result += " На руках наручники.";
		}
		
		if(cr.ParamBase[CR_BLOOD] <= 2000){
			if( result.length() > 0 && result[ result.length() - 1 ] != "." )
				result += ".";
			result += " выглядит крайне бледно.";
		}

	}

    // Format tags
    if( cr.Lexems != "" )
        return FormatTags( result, cr.Lexems );
    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Elevator generation.
// Data specification:
// 1
// 1 start level
// 1 levels count
// 1 main pic
// 2 main pic width, height
// 1 additional pic offset
// 2 additional pic point
// 1 indicator animation offset in INTRFACE.LST
// 2 indicator animation point
// 1 button down pic offset in INTRFACE.LST
// 1 buttons count
// 4 rect for every button
bool get_elevator( uint type, uint[]& data )
{
    const string iface = "art\\intrface\\";
    const        uint[][] elevators =
    {
        //	 Level current, start, count               Main picture size                          Additional picture size                            Indicator animation size                  Buttons count
        //	         Main picture                               Additional picture                       Indicator animation                                  Button down picture                 Button coordinates
        // 0) BOS 1234
        { 0, 1, 4,  GetStrHash( iface + "EL_BOS.FRM" ),   230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 4, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211, 11, 222, 58, 271 },
        // 1) BOS G1
        { 0, 0, 2,  GetStrHash( iface + "EL_BOS.FRM" ),   230, 284, GetStrHash( iface + "EL_BOS2.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 2) Master 123
        { 0, 1, 3,  GetStrHash( iface + "EL_MAST1.FRM" ), 230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 3) Master 34
        { 0, 3, 2,  GetStrHash( iface + "EL_MAST1.FRM" ), 230, 284, GetStrHash( iface + "EL_MAST2.FRM" ), 0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 4) Military 123
        { 0, 1, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 5) Military 34
        { 0, 3, 4,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL2.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 6) Military 346
        { 0, 3, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL3.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 7) Military 456
        { 0, 4, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL4.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 8) Vault 123
        { 0, 1, 3,  GetStrHash( iface + "EL_VAULT.FRM" ), 230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
    };

    uint index        = ( type & 0xFFFF );
    uint currentLevel = ( type >> 16 );

    if( index > 8 )
        return false;
    data.resize( elevators[ index ].length() );
    for( uint i = 0; i < data.length(); i++ )
        data[ i ] = elevators[ index ][ i ];
    data[ 0 ] = currentLevel;
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Music/Video, see media.fos
void _PlayMusic( int pos, int repeat, int, string@ musicName, int[] @ )
{
    PlayMusic( musicName, uint( pos ), uint( repeat ) );
}

void _PlayVideo( int canStop, int, int, string@ videoName, int[] @ )
{
    PlayVideo( videoName, canStop != 0 );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Effects, see effects.fos
void _FlushScreen( int fromColor, int toColor, int timeMs, string@, int[] @ )
{
    FlushScreen( fromColor, toColor, timeMs );
}

void _QuakeScreen( int noise, int timeMs, int, string@, int[] @ )
{
    QuakeScreen( noise, timeMs );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set __CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost( ItemCl& item, CritterCl& chosen, CritterCl& npc, bool sell )
{
    return sell ? 1 : 2;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine perk aviability.
bool check_perk( CritterCl& cr, uint perk )
{
    return PerkCheck( cr, perk );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to calculate registration data.
void player_data_generate( int[]& params )
{
    if( __RegParams is null )
    {
        int[] regParams;
        @__RegParams = regParams;
        __RegParams.resize( PARAMS_COUNT );

        __RegParams[ ST_STRENGTH ] = 5;
        __RegParams[ ST_PERCEPTION ] = 5;
        __RegParams[ ST_ENDURANCE ] = 5;
        __RegParams[ ST_CHARISMA ] = 5;
        __RegParams[ ST_INTELLECT ] = 5;
        __RegParams[ ST_AGILITY ] = 5;
        __RegParams[ ST_LUCK ] = 5;
        __RegParams[ ST_AGE ] = Random( AGE_MIN, AGE_MAX );
        __RegParams[ ST_GENDER ] = GENDER_MALE;
    }

    params = __RegParams;

    CritterGenerate( params );

    #ifdef PLAYERS_3D
    Set3DRegistrationGender( params[ ST_GENDER ] );
    #endif
}

bool player_data_check( int[]& params )
{
    #ifdef PLAYERS_3D
    Fill3DRegistrationParameters( params );
    #endif

    // Check name
    uint nameError = CheckPlayerName( __RegName );
    if( nameError != 0 )
    {
        Message( GetMsgStr( TEXTMSG_GAME, nameError ) );
        return false;
    }

    return CritterGenerateCheck( params );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on some critter action.
void critter_action( bool localCall, CritterCl& cr, int action, int actionExt, ItemCl@ item )
{
    // Not process locally called actions
    if( cr.IsChosen() && not localCall )
    {
        switch( action )
        {
        case ACTION_MOVE_ITEM:
        case ACTION_MOVE_ITEM_SWAP:
        case ACTION_USE_ITEM:
        case ACTION_DROP_ITEM:
        case ACTION_USE_WEAPON:
        case ACTION_RELOAD_WEAPON:
        case ACTION_USE_SKILL:
        case ACTION_PICK_ITEM:
        case ACTION_PICK_CRITTER:
        case ACTION_OPERATE_CONTAINER:
            return;             // Skip processing
        default:
            break;              // Processing
        }
    }

    uint8            mode = 0;
    const ProtoItem@ proto = ( valid( item ) ? item.Proto : cr.GetSlotProto( SLOT_HAND1, mode ) );
    if( ( action >= ACTION_MOVE_ITEM && action <= ACTION_OPERATE_CONTAINER ) || action == ACTION_STANDUP )
        cr.Wait( cr.Param[CR_BREAKTIME] );

    switch( action )
    {
    case ACTION_MOVE:
        break;
    case ACTION_RUN:
        break;
    case ACTION_MOVE_ITEM:
        if( cr.IsLife() )
        {
            uint8 fromSlot = actionExt;
            uint8 toSlot = item.CritSlot;

            cr.ClearAnim();

            if( toSlot == SLOT_HAND1 ){
				if( cr.IsChosen() && proto.Type == ITEM_TYPE_WEAPON){
					RunServerScriptUnsafe("rp_utils@unsafe_ShowWeapon", item.Id, ANIM2_SHOW_WEAPON, 0, null, null);
					cr.Wait(CLAMP(proto.Weapon_Show_Time - (cr.Param[ST_AGILITY] * 20), 100, 10000));
				}
				cr.Animate( 0, ANIM2_SHOW_WEAPON, item );
			}
            else if( fromSlot == SLOT_HAND1 ){
				if( cr.IsChosen() && proto.Type == ITEM_TYPE_WEAPON){
					RunServerScriptUnsafe("rp_utils@unsafe_ShowWeapon", item.Id, ANIM2_HIDE_WEAPON, 0, null, null);
					cr.Wait(CLAMP(proto.Weapon_Show_Time - (cr.Param[ST_AGILITY] * 20), 100, 10000));
				}
                cr.Animate( 0, ANIM2_HIDE_WEAPON, item );
			}
            else
            cr.Animate( 0, ANIM2_SWITCH_ITEMS );
        }
        break;
    case ACTION_MOVE_ITEM_SWAP:
        break;
    case ACTION_USE_ITEM:
        if( cr.IsLife() && valid( proto ) )
        {
            cr.ClearAnim();

            if( proto.Type == ITEM_TYPE_WEAPON && FLAG( proto.Flags, ITEM_CAN_USE_ON_SMTH ) && cr.IsAnimAviable( proto.Weapon_Anim1, proto.Weapon_Anim2_0 ) )
                cr.Animate( proto.Weapon_Anim1, proto.Weapon_Anim2_0, item );
            else
                cr.Animate( 0, ANIM2_USE, item );
        }
        break;
    case ACTION_DROP_ITEM:
        if( cr.IsLife() )
        {
            cr.ClearAnim();
            cr.Animate( 0, ANIM2_PICKUP );
        }
        break;
    case ACTION_USE_WEAPON:
        if( cr.IsLife() && valid( proto ) )
        {
            int  use   = ( actionExt & 0xF );
            int  aim   = ( ( actionExt >> 4 ) & 0xF );
            bool fail = ( ( ( actionExt >> 8 ) & 1 ) != 0 );

            cr.ClearAnim();

            cr.Animate( 0, ANIM2_PREPARE_WEAPON );

            PlaySound( 'W', SOUND_WEAPON_USE, _WeaponSoundId( proto, use ), use != 1 ? '1' : '2' );
            cr.Animate( 0, _WeaponAnim2( proto, use ), item );

            if( fail )
                cr.Animate( 0, ANIM2_DAMAGE_FRONT, item );
            else
                cr.Animate( 0, ANIM2_TURNOFF_WEAPON );
				
			uint skillMul = proto.Weapon_IsRevolver ? 4 : 1;
			uint breakTime = cr.Param[CR_BREAKTIME];
			if( proto.Weapon_Use_Time != 0){
				breakTime = CLAMP( proto.Weapon_Use_Time - (cr.Param[_WeaponSkill(proto, use)] * skillMul) - (cr.Param[ST_AGILITY] * 25), 100, 10000);
			}
			cr.Wait(breakTime);
        }
        break;
    case ACTION_RELOAD_WEAPON:
        if( cr.IsLife() && valid( proto ) )
        {
            cr.ClearAnim();
            PlaySound( 'W', SOUND_WEAPON_RELOAD, proto.Weapon_SoundId_0, '1' );
            cr.Animate( item.Proto.Weapon_Anim1, ANIM2_RELOAD, item );
			cr.Wait(CLAMP(proto.Weapon_Reload_Time - (cr.Param[ST_AGILITY] * 10), 100, 10000));
        }
        break;
    case ACTION_USE_SKILL:
        if( cr.IsLife() && actionExt != SK_SNEAK && actionExt != SK_STEAL && actionExt != SK_SCIENCE )
        {
            cr.ClearAnim();
            cr.Animate( 0, ANIM2_USE );
        }
        break;
    case ACTION_PICK_ITEM:
        if( cr.IsLife() && valid( proto ) )
        {
            cr.ClearAnim();
            cr.Animate( 0, proto.GroundLevel ? ANIM2_PICKUP : ANIM2_USE );
        }
        break;
    case ACTION_PICK_CRITTER:
        if( cr.IsLife() )
        {
            cr.ClearAnim();

            switch( actionExt )           // 0 - loot, 1 - steal, 2 - push
            {
            case 0:
                cr.Animate( 0, ANIM2_LOOT );
                break;
            //case 1:
            //    cr.Animate( 0, ANIM2_STEAL );
            //    break;
            case 2:
                cr.Animate( 0, ANIM2_PUSH );
                break;
            default:
                break;
            }
        }
        break;
    case ACTION_OPERATE_CONTAINER:
        if( cr.IsLife() )
        {
            cr.ClearAnim();
            int transferType  = actionExt / 10;
            int directionType = actionExt % 10;

            if( transferType == TRANSFER_HEX_CONT_DOWN || transferType == TRANSFER_CRIT_LOOT )
                cr.Animate( 0, ANIM2_PICKUP );
            else
                cr.Animate( 0, ANIM2_USE );
        }
        break;
    case ACTION_DODGE:
        if( not cr.IsAnimPlaying() && cr.IsLife() )
        {
            cr.Animate( 0, actionExt == 0 ? ANIM2_DODGE_FRONT : ANIM2_DODGE_BACK );
        }
        break;
    case ACTION_DAMAGE:
        if( not cr.IsAnimPlaying() )
        {
            if( cr.IsLife() )
                cr.Animate( 0, actionExt == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK );
            else if( cr.IsKnockout() )
                cr.Animate( 0, actionExt == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK );
        }
        else
        {
            // Todo:
            // ANIM2_WALK_DAMAGE_FRONT
            // ANIM2_WALK_DAMAGE_BACK
            // ANIM2_LIMP_DAMAGE_FRONT
            // ANIM2_LIMP_DAMAGE_BACK
            // ANIM2_RUN_DAMAGE_FRONT
            // ANIM2_RUN_DAMAGE_BACK
        }
        break;
    case ACTION_DAMAGE_FORCE:
        if( cr.IsLife() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK );
        }
        else if( cr.IsKnockout() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK );
        }
        break;
    case ACTION_KNOCKOUT:
        if( not cr.IsKnockout() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt );
        }
        break;
    case ACTION_STANDUP:
        if( cr.IsKnockout() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt );
        }
        break;
    case ACTION_FIDGET:
        if( cr.IsLife() && not cr.IsAnimPlaying() )
        {
            cr.Animate( 0, ANIM2_FIDGET );
        }
        break;
    case ACTION_DEAD:
        if( not cr.IsDead() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt );
        }
        break;
    case ACTION_CONNECT:
        break;
    case ACTION_DISCONNECT:
        break;
    case ACTION_RESPAWN:
        break;
    case ACTION_REFRESH:
        break;
    default:
        break;
    }
	GUI_EngineCallback_ItemChanged(false);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 2d animation playing.
void animation2d_process( bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item )
{
	if(cr.IsChosen())
		RunServerScriptUnsafe("rp_utils@unsafe_MoveCallBack", anim2, 0,0,null,null);
    if( !animateStay )
        PlayAnimSound( cr.CrType, cr.Stat[ ST_GENDER ], anim1, anim2 );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 3d animation playing.
void animation3d_process( bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item )
{
    if( !animateStay )
        PlayAnimSound( cr.CrType, cr.Stat[ ST_GENDER ], anim1, anim2 );

    #ifdef PLAYERS_3D
    // You must implement this pids
    # define PID_STRAWHAT             uint( -1 )     // Head slot
    # define PID_ARMIN_CAP            uint( -2 )     // Head slot
    # define PID_POWER_HELMET         uint( -3 )     // Head slot
    # define PID_MOTORCYCLE_HELMET    uint( -4 )     // Head slot
    # define PID_TIBBETS_PRISON       uint( -5 )     // Armor slot
    # define PID_VAULT_SUIT           uint( -6 )     // Armor slot

    // Change values
    uint8   mode = 0;
    uint16  armorPid   = ( valid( cr.GetSlotProto( SLOT_ARMOR, mode ) ) ? cr.GetSlotProto( SLOT_ARMOR, mode ).ProtoId : 0 );
    uint16  weapPid    = ( valid( item ) ? item.GetProtoId() : cr.GetSlotProto( SLOT_HAND1, mode ).ProtoId );
    uint16  weapExPid  = ( valid( cr.GetSlotProto( SLOT_HAND2, mode ) ) ? cr.GetSlotProto( SLOT_HAND2, mode ).ProtoId : 0 );
    ItemCl@ armorItem = cr.GetItem( 0, SLOT_ARMOR );
    ItemCl@ headItem  = null;

    # ifndef PLAYERS_3D_NO_HEAD
    uint16 headPid    = ( valid( cr.GetSlotProto( SLOT_HEAD,  mode ) ) ? cr.GetSlotProto( SLOT_HEAD,  mode ).ProtoId : 0 );
    @headItem         = cr.GetItem( 0, SLOT_HEAD );
    # endif
    # ifdef PLAYERS_3D_NO_HEAD
    uint16 headPid    = 0;
    # endif

    bool weapBigGun = false;
    if( valid( item ) )
    {
        if( FLAG( item.Flags, ITEM_BIG_GUN ) )
            weapBigGun = true;
    }
    else
    {
        ItemCl@ weap = cr.GetItem( 0, SLOT_HAND1 );
        if( valid( weap ) && FLAG( weap.Flags, ITEM_BIG_GUN ) )
            weapBigGun = true;
    }

    int rhandleAtr  = 0;
    int lhandleAtr  = 0;
    int handsAtr    = 0;
    int bodyAtr     = 0;
    int feetAtr     = 0;
    int headAtr     = 0;
    int eyeAtr      = 0;
    int shoulderAtr = 0;
    int backAtr     = 0;
    int backpackAtr = 0;

    /*switch(armorPid)
       {
       case PID_LEATHER_JACKET:
            bodyAtr     = ATTRIBUTE_Body_LeatherOutfit;
            handsAtr    = ATTRIBUTE_Hands_LeatherOutfit; // ATTRIBUTE_Hands_LeatherOutfitGauntlet
            feetAtr     = ATTRIBUTE_Feet_LeatherOutfit;
            shoulderAtr = ATTRIBUTE_Shoulderpieces_LeatherOutfit;
            break;
       case PID_POWERED_ARMOR:
       case PID_HARDENED_POWER_ARMOR:
            bodyAtr     = ATTRIBUTE_Body_PowerArmor;
            handsAtr    = ATTRIBUTE_Hands_PowerArmor;
            feetAtr     = ATTRIBUTE_Feet_PowerArmor;
            shoulderAtr = ATTRIBUTE_Shoulderpieces_PowerArmor;
            headAtr     = ATTRIBUTE_Head_ArmingCap;
       #ifdef PLAYERS_3D_NO_HEAD
            headAtr     = ATTRIBUTE_Head_PowerArmor;
       #endif
            break;
       case PID_TIBBETS_PRISON:
            bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
            feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
            backAtr     = armorItem.Val5;
            break;
       case PID_VAULT_SUIT:
            bodyAtr     = ATTRIBUTE_Body_VaultSuit;
            feetAtr     = ATTRIBUTE_Feet_VaultSuit;
            backAtr     = armorItem.Val5;
            break;
            // Missed models, set some default clothes
       case PID_LEATHER_ARMOR:
       case PID_LEATHER_ARMOR_MK_II:
       case PID_CURED_LEATHER_ARMOR:
       case PID_METAL_ARMOR:
       case PID_METAL_ARMOR_MK_II:
       case PID_TESLA_ARMOR:
       case PID_COMBAT_ARMOR:
       case PID_COMBAT_ARMOR_MK_II:
       case PID_BROTHERHOOD_COMBAT_ARMOR:
       case PID_ADVANCED_POWER_ARMOR:
       case PID_ADVANCED_POWER_ARMOR_MK2:
       case PID_PURPLE_ROBE:
       case PID_KEEPBRIGE_ROBE:
            bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
            feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
            break;
       default:
            break;
       }*/

    // Temporary sets, mostly intended for work with PLAYERS_3D_NO_HEAD
    // Will be corrected as the development of the missing content
    switch( armorPid )
    {
    case PID_LEATHER_JACKET:
        bodyAtr     = ATTRIBUTE_Body_LeatherOutfit;
        handsAtr    = ATTRIBUTE_Hands_LeatherOutfit;
        feetAtr     = ATTRIBUTE_Feet_LeatherOutfit;
        break;

    case PID_POWERED_ARMOR:
    case PID_HARDENED_POWER_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_PowerArmor;
        handsAtr    = ATTRIBUTE_Hands_PowerArmor;
        feetAtr     = ATTRIBUTE_Feet_PowerArmor;
        headAtr     = ATTRIBUTE_Head_ArmingCap;
        break;

    case PID_TIBBETS_PRISON:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        backAtr     = armorItem.Val5;
        break;

    case PID_JUMPSUIT:
    case PID_FAKE_JUMPSUIT:
    case PID_VAULT_SUIT:
        bodyAtr     = ATTRIBUTE_Body_VaultSuit;
        feetAtr     = ATTRIBUTE_Feet_VaultSuit;
        backAtr     = armorItem.Val5;
        break;

    case PID_LEATHER_ARMOR:
    case PID_LEATHER_ARMOR_MK_II:
    case PID_CURED_LEATHER_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_LeatherOutfit;
        handsAtr    = ATTRIBUTE_Hands_LeatherOutfitGauntlet;
        feetAtr     = ATTRIBUTE_Feet_LeatherOutfit;
        shoulderAtr = ATTRIBUTE_Shoulderpieces_LeatherOutfit;
        break;

    case PID_METAL_ARMOR:
    case PID_METAL_ARMOR_MK_II:
    case PID_TESLA_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_PowerArmor;
        feetAtr     = ATTRIBUTE_Feet_PowerArmor;
        break;

    case PID_COMBAT_ARMOR:
    case PID_COMBAT_ARMOR_MK_II:
    case PID_BROTHERHOOD_COMBAT_ARMOR:
    case PID_CHITIN_ARMOR_MK_II:
    case PID_CHITIN_ARMOR:
    case PID_BLACK_COMBAT_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_CombatArmor;
        handsAtr    = ATTRIBUTE_Hands_CombatArmor;
        feetAtr     = ATTRIBUTE_Feet_CombatArmor;
        shoulderAtr = ATTRIBUTE_Shoulderpieces_CombatArmor;
        # ifdef PLAYERS_3D_NO_HEAD
        headAtr     = ATTRIBUTE_Head_CombatArmor;
        # endif
        break;

    case PID_ADVANCED_POWER_ARMOR:
    case PID_ADVANCED_POWER_ARMOR_MK2:
        bodyAtr     = ATTRIBUTE_Body_PowerArmor;
        handsAtr    = ATTRIBUTE_Hands_PowerArmor;
        feetAtr     = ATTRIBUTE_Feet_PowerArmor;
        shoulderAtr = ATTRIBUTE_Shoulderpieces_PowerArmor;
        headAtr     = ATTRIBUTE_Head_PowerArmor;
        break;

    case PID_PURPLE_ROBE:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        break;
    case PID_KEEPBRIGE_ROBE:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        headAtr     = ATTRIBUTE_Head_StrawHat;
        break;
    case PID_BLACK_ROBE:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        headAtr     = ATTRIBUTE_Head_ArmingCap;
        break;

    default:
        break;
    }

    // Head
    switch( headPid )
    {
    case PID_STRAWHAT:
        headAtr     = ATTRIBUTE_Head_StrawHat;
        break;
    case PID_ARMIN_CAP:
        headAtr     = ATTRIBUTE_Head_ArmingCap;
        break;
    case PID_POWER_HELMET:
        headAtr     = ATTRIBUTE_Head_PowerArmor;
        break;
    case PID_MOTORCYCLE_HELMET:
        headAtr     = ( headItem.Val5 != 0 ? headItem.Val5 : ATTRIBUTE_Head_Motorcycle_White );
        break;
    default:
        break;
    }

    // Backpack
    if(     weapPid   == PID_BAG || weapPid   == PID_BROWN_BAG )
        backpackAtr = ATTRIBUTE_Backpack_PaLg01;
    else if( weapPid   == PID_BACKPACK )
        backpackAtr = ATTRIBUTE_Backpack_PaSm01;
    else if( weapExPid == PID_BAG || weapExPid == PID_BROWN_BAG )
        backpackAtr = ATTRIBUTE_Backpack_PaLg01;
    else if( weapExPid == PID_BACKPACK )
        backpackAtr = ATTRIBUTE_Backpack_PaSm01;

    // Hands
    if( weapPid == PID_POWER_FIST || weapPid == PID_MEGA_POWER_FIST )
    {
        handsAtr = ATTRIBUTE_Hands_PowerFist;
    }
    else if( weapBigGun )
    {
        rhandleAtr = GetHandleValue( weapPid );
    }
    else
    {
        rhandleAtr = GetHandleValue( weapPid );
        lhandleAtr = GetHandleValue( weapExPid );
    }

    # ifdef PLAYERS_3D_VAULT_SUITE
    bool isSkeleton = ( cr.CrType == CRTYPE_3D_MALE_SKELETON || cr.CrType == CRTYPE_3D_FEMALE_SKELETON );
    if( bodyAtr == 0 && !isSkeleton )
        bodyAtr = ATTRIBUTE_Body_VaultSuit;
    # endif

    cr.Anim3dLayer[ ANIM3D_LAYER_RHANDLE ] = rhandleAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_LHANDLE ] = lhandleAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_BODY    ] = bodyAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_FEET    ] = feetAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_HANDS   ] = handsAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_HEAD    ] = headAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_SHOULDER ] = shoulderAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_EYE     ] = eyeAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_BACK    ] = backAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_BACKPACK ] = backpackAtr;

    // Set custom values
    for( uint i = ANIM3D_LAYER_SKIN; i <= ANIM3D_LAYER_BACKPACK; i++ )
        if( cr.Stat[ ST_ANIM3D_LAYERS + i ] != 0 )
            cr.Anim3dLayer[ i ] = cr.Stat[ ST_ANIM3D_LAYERS + i ];
    #endif
}

#ifdef PLAYERS_3D
int GetHandleValue( uint16 pid )
{
    if( pid == 0 || ( pid >= 1000 && pid <= 1100 ) )
        return 0;

    int handle = 0;
    switch( pid )
    {
    case PID_ZIP_GUN:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_9MM_MAUSER:
        handle = ATTRIBUTE_Handle_Weapon_9mmAutoloader;
        break;
    case PID_10MM_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_14MM_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_DESERT_EAGLE:
        handle = ATTRIBUTE_Handle_Weapon_45Autoloader;
        break;
    case PID_DESERT_EAGLE_EXT_MAG:
        handle = ATTRIBUTE_Handle_Weapon_45Autoloader_GunExtClip;
        break;
    case PID_223_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_223Autoloader;
        break;
    case PID_44_MAGNUM_REVOLVER:
        handle = ATTRIBUTE_Handle_Weapon_44Revolver;
        break;
    case PID_44_MAGNUM_SPEEDLOADER:
        handle = ATTRIBUTE_Handle_Weapon_44Revolver;
        break;
    case PID_NEEDLER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_PK12_GAUSS_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_2mmGaussPistol;
        break;
    case PID_HUNTING_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SCOPED_HUNTING_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SPRINGER_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_ASSAULT_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_ASSAULT_RIFLE_EXT_MAG:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SNIPER_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_FN_FAL:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_FN_FAL_NIGHT_SCOPE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_FN_FAL_HPFA:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_RED_RYDER_BB_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_RED_RYDER_LE_BB_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_JONNY_BB_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_INDEPENDENT:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_M72_GAUSS_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_ELEPHANT_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SHOTGUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SAWED_OFF_SHOTGUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_COMBAT_SHOTGUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_HK_CAWS:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_PANCOR_JACKHAMMER:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_10MM_SMG:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_HK_P90C:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_TOMMY_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_HK_G11:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_HK_G11E:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_GREASE_GUN:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_FLAMER:
        handle = ATTRIBUTE_Handle_Weapon_Flamethrower;
        break;
    case PID_IMPROVED_FLAMETHROWER:
        handle = ATTRIBUTE_Handle_Weapon_Flamethrower_FlamerExtTank;
        break;
    case PID_ROCKET_LAUNCHER:
        handle = ATTRIBUTE_Handle_Weapon_15mmArtemisRailGun;
        break;
    case PID_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_AVENGER_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_VINDICATOR_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_BOZAR:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_LIGHT_SUPPORT_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_M60:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_LASER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_MAGNETO_LASER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_SOLAR_SCORCHER:
        handle = ATTRIBUTE_Handle_Weapon_APOLLOLaserPistol;
        break;
    case PID_LASER_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_LASER_RIFLE_EXT_CAP:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_GATLING_LASER:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_ALIEN_LASER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_APOLLOLaserPistol;
        break;
    case PID_PLASMA_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_PLASMA_PISTOL_EXT_CART:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_PLASMA_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_TURBO_PLASMA_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_YK32_PULSE_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_2mmGaussPistol;
        break;
    case PID_YK42B_PULSE_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_MOLOTOV_COCKTAIL:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeFrag;
        break;
    case PID_FRAG_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeFrag;
        break;
    case PID_PLASMA_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadePlasma;
        break;
    case PID_PULSE_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeEMP;
        break;
    case PID_FLARE:
        handle = ATTRIBUTE_Handle_Weapon_Flare;
        break;
    case PID_ACTIVE_FLARE:
        handle = ATTRIBUTE_Handle_Weapon_Flare;
        break;
    case PID_PLANT_SPIKE:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_THROWING_KNIFE:
        handle = ATTRIBUTE_Handle_Weapon_ThrowingKnife;
        break;
    case PID_ROCK:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_GOLD_NUGGET:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_URANIUM_ORE:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_REFINED_ORE:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_KNIFE:
        handle = ATTRIBUTE_Handle_Weapon_CombatKnife;
        break;
    case PID_COMBAT_KNIFE:
        handle = ATTRIBUTE_Handle_Weapon_CombatKnife;
        break;
    case PID_LIL_JESUS_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_CombatKnife;
        break;
    case PID_SHIV:
        handle = ATTRIBUTE_Handle_Weapon_Shiv;
        break;
    case PID_SWITCHBLADE:
        handle = ATTRIBUTE_Handle_Weapon_Switchblade;
        break;
    case PID_WAKIZASHI_BLADE:
        handle = ATTRIBUTE_Handle_Weapon_Machete;
        break;
    case PID_SPEAR:
        handle = ATTRIBUTE_Handle_Weapon_Spear;
        break;
    case PID_SHARP_SPEAR:
        handle = ATTRIBUTE_Handle_Weapon_Spear;
        break;
    case PID_SHARPENED_POLE:
        handle = ATTRIBUTE_Handle_Weapon_Spear;
        break;
    case PID_AXE:
        handle = ATTRIBUTE_Handle_Weapon_Hatchet;
        break;
    case PID_CLUB:
        handle = ATTRIBUTE_Handle_Weapon_NightStick;
        break;
    case PID_CROWBAR:
        handle = ATTRIBUTE_Handle_Weapon_Crowbar;
        break;
    case PID_WRENCH:
        handle = ATTRIBUTE_Handle_Weapon_HeavyWrench;
        break;
    case PID_SLEDGEHAMMER:
        handle = ATTRIBUTE_Handle_Weapon_Sledgehammer;
        break;
    case PID_LOUISVILLE_SLUGGER:
        handle = ATTRIBUTE_Handle_Weapon_Baseballbat;
        break;
    case PID_SUPER_SLEDGE:
        handle = ATTRIBUTE_Handle_Weapon_Sledgehammer;
        break;
    case PID_CATTLE_PROD:
        handle = ATTRIBUTE_Handle_Weapon_CattleProd;
        break;
    case PID_SUPER_CATTLE_PROD:
        handle = ATTRIBUTE_Handle_Weapon_CattleProd;
        break;
    case PID_RIPPER:
        handle = ATTRIBUTE_Handle_Weapon_Machete;
        break;
    case PID_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_PLATED_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_RING_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_RING_PLATED_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_BRASS_KNUCKLES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_SPIKED_KNUCKLES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_DYNAMITE:
        handle = ATTRIBUTE_Handle_Weapon_Dynamite;
        break;
    case PID_PLASTIC_EXPLOSIVES:
        handle = ATTRIBUTE_Handle_Weapon_Dynamite;
        break;
    case PID_MINE:
        handle = ATTRIBUTE_Handle_Weapon_Dynamite;
        break;
    // Player will never have this weapons anyway
    case PID_ROBO_ROCKET_LAUNCHER:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_PHAZER:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_DEATHCLAW_CLAW_1:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_DEATHCLAW_CLAW_2:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_FIRE_GECKO_FLAME_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_Flamethrower;
        break;
    case PID_SPECIAL_BOXER_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_GUN_TURRET_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_EYEBALL_FIST_1:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_EYEBALL_FIST_2:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_DUAL_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_HEAVY_DUAL_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_END_BOSS_KIFE:
        handle = ATTRIBUTE_Handle_Weapon_Machete;
        break;
    case PID_END_BOSS_PLASMA_GUN:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_HOLY_HAND_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeFrag;
        break;
    // Other items
    case PID_STIMPAK:
    case PID_RADAWAY:
    case PID_SUPER_STIMPAK:
    case PID_HYPO:
    case PID_PSYCHO:
    case PID_HYPO_POISON:
        handle = ATTRIBUTE_Handle_Item_FirstAidKit;
        break;
    case PID_LOCKPICKS:
    case PID_EXP_LOCKPICK_SET:
    case PID_ELECTRONIC_LOCKPICKS:
    case PID_ELEC_LOCKPICK_MKII:
        handle = ATTRIBUTE_Handle_Item_SecurityKit;
        break;
    case PID_MULTI_TOOL:
    case PID_SUPER_TOOL_KIT:
    case PID_OIL_CAN:
        handle = ATTRIBUTE_Handle_Item_Toolkit;
        break;
    // No handle
    case PID_POWER_FIST:
    case PID_MEGA_POWER_FIST:
    case PID_BAG:
    case PID_BROWN_BAG:
    case PID_BACKPACK:
        handle = 0;
        break;
    // Generic item
    default:
        handle = 0;
        break;
    }

    return handle;
}
#endif

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on some items collection generating.
// To force function call use RefreshItemsCollection(int collection)
// Collection constants see in Items collections _client_defines.fos
// If you want disable showing than just null pointer in collection
void items_collection( int collection, ItemCl@[]& items )
{
    // Example
    // Disable showing of all weapons in USE mode:
    /*if(collection == ITEMS_USE)
       {
            for(uint i = 0, j = items.length(); i < j; i++)
                    if(items[i].GetType() == ITEM_TYPE_WEAPON)
                            @items[i] = null;
       }*/
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on log file saving.
void filename_logfile( string& filename )
{
    filename = "messagebox\\" + filename;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on screenshot saving.
void filename_screenshot( string& filename )
{
    filename = "screenshots\\" + filename;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on message added to message box.
// Parameters messageText and messageType can be changed for engine handler.
void message_box( string& messageText, int messageType, bool scriptCall )
{
    GUIMessageBox@[] messageBoxes;
    GUI_CollectMessageBoxes( messageBoxes );
    for( uint i = 0; i < messageBoxes.length(); i++ )
        messageBoxes[ i ].AddMessage( messageText, messageType );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called to check interface hit.
bool check_interface_hit( int x, int y )
{
    return GUI_EngineCallback_CheckInterfaceHit( x, y );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called to check current container item under mouse.
bool get_cont_item( uint& itemId, bool& isEnemy )
{
    GUIScreen@ screen = GUI_GetActiveScreen();
    if( screen is null || screen.IsHardcoded || screen.Index != CLIENT_SCREEN_INVENTORY )
        return false;

    if( GetCurrentCursor() == CURSOR_DEFAULT )
    {
        GUIObject@ hitObj = screen.FindMouseHit();
        if( hitObj !is null && hitObj.Grid !is null )
        {
            GUIItemView@ itemView = cast< GUIItemView >( hitObj.Grid );
            if( itemView !is null )
            {
                ItemCl@ item = itemView.GetItem( hitObj.CellIndex );
                if( item !is null )
                {
                    itemId = item.Id;
                    isEnemy = ( itemView.CritterId != 0 );
                }
            }
        }
    }

    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Items and drop handler.
bool ItemsDragAndDropHandler( GUIObject& obj, GUIObject@ target )
{
    if( obj.Grid is null )
        return false;
		
    //if( target !is null && target.Grid is null )
    //    return false;
    // Destination
    GUIItemView@ targetItemView;
    ItemCl@      targetItem;
    if( target !is null )
    {
        if( target.Grid !is null )
        {
            @targetItemView = cast< GUIItemView >( target.Grid );
            if( targetItemView is null )
                return false;
            @targetItem = targetItemView.GetItem( target.CellIndex );
        }
        else
        {
            @targetItemView = cast< GUIItemView >( target );
            if( targetItemView is null )
                return false;
        }
    }

    // Source
    GUIItemView@ objItemView = cast< GUIItemView >( obj.Grid );
    //GUIItemView@ targetItemView = ( target !is null ? cast< GUIItemView >( target.Grid ) : null );
    if( objItemView is null )
        return false;

    ItemCl@ objItem = objItemView.GetItem( obj.CellIndex );
    //ItemCl@ targetItem = ( targetItemView !is null ? targetItemView.GetItem( target.CellIndex ) : null );
    if( objItem is null )
        return false;

    int objSlot = objItemView.UserData;
    int targetSlot = ( targetItemView !is null ? targetItemView.UserData : SLOT_GROUND );
    if( objSlot == targetSlot )
        return false;

    if( targetSlot != SLOT_INV && objItem !is null && targetItem !is null && objItem.GetType() == ITEM_TYPE_AMMO && targetItem.GetType() == ITEM_TYPE_WEAPON )
    {
        if( objItem.Proto.Ammo_Caliber == targetItem.Proto.Weapon_Caliber &&
            ( targetItem.AmmoCount < targetItem.Proto.Weapon_MaxAmmoCount || targetItem.AmmoPid != objItem.GetProtoId() ) )
        {
            uint[] actions;
            GetChosenActions( actions );
            uint[] useItemAction = { CHOSEN_USE_ITEM, targetItem.Id, 0, TARGET_SELF_ITEM, objItem.Id, USE_RELOAD, 0 };
            for( uint i = 0; i < useItemAction.length(); i++ )
                actions.insertLast( useItemAction[ i ] );
				
            SetChosenActions( actions );
        }
    }
    else if( targetSlot == SLOT_GROUND && objItem.IsStackable() && objItem.GetCount() > 1 )
    {
        CustomCall( "SplitDrop " + objItem.Id );
    }
    else
    {
        uint[] actions;
        GetChosenActions( actions );
        uint[] useItemAction = { CHOSEN_MOVE_ITEM, objItem.Id, objItem.GetCount(), targetSlot, 0, 0, 0 };
        for( uint i = 0; i < useItemAction.length(); i++ )
            actions.insertLast( useItemAction[ i ] );
        SetChosenActions( actions );
    }

    return true;
}

int getHpPercentage(CritterCl& cr){
	int allHp = 0;
	for(int i = CR_INTERNALS_DAMAGE; i <= CR_HEAD_DAMAGE; i++){
		if(cr.Param[i] > allHp)
			allHp = cr.Param[i];
	}
	allHp = 100 - allHp;
	
	int allBurn = 0;
	for(int i = CR_LEFT_ARM_BURN; i <= CR_HEAD_BURN; i++){
		if(cr.Param[i] > allBurn)
			allBurn = cr.Param[i];
	}
	allBurn = 100 - allBurn ;
	
	allHp = CLAMP(allHp, 0, 100);
	allBurn = CLAMP(allBurn, 0, 100);
	
	return allHp < allBurn ? allHp : allBurn;
}

void __test_print(int, int, int, string@ str, int[]@ arr){
	Message(str);
}

void __setCountDownTime(int time, int, int, string@, int[]@){
	__TimeBeforeStart = time;
}

void __ReloadMag(int, int, int, string@ str, int[]@ arr){
	CritterCl@ chosen = GetChosen();
	ItemCl@ item = _CritGetItemHand(chosen);
    const ProtoItem@ proto = item.Proto;

	ItemCl@[] items;
	chosen.GetItems(-1, items);
	const ItemCl@ mag;
	
	for(uint i = 0; i < items.length(); i++)
	{
		ItemCl@ candidate = items[i];
		if(candidate.GetType() == ITEM_TYPE_AMMO && candidate.Proto.Ammo_Caliber == proto.Weapon_Caliber && candidate.AmmoCount > 0){
			if(valid(mag) && candidate.AmmoCount < mag.AmmoCount){
				continue;
			}
			@mag = @candidate;								
		}
		
	}
	
	if(valid(mag)){
		uint[] actions;
		GetChosenActions( actions );
		uint[] useItemAction = { CHOSEN_USE_ITEM, item.Id, 0, TARGET_SELF_ITEM, mag.Id, USE_RELOAD, 0 };
		for( uint i = 0; i < useItemAction.length(); i++ )
			actions.insertLast( useItemAction[ i ] );
			
		SetChosenActions( actions );
		CustomCall( "NextItemMode" );
	}
	
	return;
}

void retrieveAccess(int, int, int, string@ str, int[]@ arr){
	RunServerScriptUnsafe("rp_utils@unsafe_RetrieveAccess", 0, 0, 0, "" + GetStrHash(__HardwareId), null);
}

void __InformAccess(int access, int, int, string@ str, int[]@ arr){
	switch(access){
		case UNKNOWN:
			Message("Ваш уровень доступа: базовый");
			break;
		case WHITELISTED:
			Message("Ваш уровень доступа: полный");
			break;
		default:
			break;
	}
}
	

void printAccessLevelString(){
	switch(GetChosen().Param[CR_CURRENT_ACCESS]){
		case UNKNOWN:
			Message("Ваш уровень доступа: базовый");
			break;
		case WHITELISTED:
			Message("Ваш уровень доступа: полный");
			break;
		default:
			break;
	}
}

void showScreenExamine(int, int, int, string@ str, int[]@ arr){
	ShowScreen(CLIENT_SCREEN_EXAMINE);
}

void showCaravanConsole(int, int, int, string@ str, int[]@ arr){
	ShowScreen(CLIENT_SCREEN_CARAVAN);
}

void updateVisible(int crId, int faceHidden, int, string@ str, int[]@ arr){
	CritterCl@ cr = GetCritter(crId);
	
	if(faceHidden > 0){
		cr.Name = "Незнакомец";
	}else{
		cr.Name = str;
	}
}

void updateReadyPlayers(int, int, int, string@ str, int[]@ arr){
	__ReadyPlayers = str;
}

void updateCitizens(int, int, int, string@ str, int[]@ arr){
	__CitizensList = str;
}